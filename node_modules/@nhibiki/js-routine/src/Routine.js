const RoutineError = require("./Error.js");
const Timer = require("./Timer.js");

const Await = Timer.Await;

class JSRoutine {

    /**
     * construct a new routine
     * @param {Function} fn callback function on each tick, as (currentTickIndex: Number) => AwaitingTimeTillNextTick: Number
     * @param {Object} param1 
     * @returns {Routine} { start(), pause(), stop(), terminate(), state, tick }
     */
    static Routine(fn, config={}) {

        // check callback IS a callable
        if (!fn || typeof fn !== 'function') RoutineError.Raise("Only function is accepted to create a routine.", RoutineError.ERROR.WRONG_TYPE);

        // initialize routine
        config = Object.assign(JSRoutine.DEFAULT_CONF, config);      
        let currentTick = 0;
        let initializedAt = 0;
        let previousRunned = 0;
        let nextTickIntv = config.tickIntv;
        let state = JSRoutine.ROUTINE_STATE.INIT;
        let _currentRoutine = {};

        let yieldStack = {};
        let waitFor = async (key) => {
            while(!yieldStack[key] || !yieldStack[key].length) {
                if (state < JSRoutine.ROUTINE_STATE.PAUSE) return null;
                await Await(JSRoutine.BASE_WAIT);
            }
            return yieldStack[key].pop(0);
        }
        let watchFor = async (checker) => {
            if (typeof checker !== "function") RoutineError.Raise("Checker should be a function", RoutineError.ERROR.WRONG_TYPE);
            
            let pass = false;
            while(!pass) {
                if (state < JSRoutine.ROUTINE_STATE.PAUSE) return false;
                try { pass = await checker.call(_currentRoutine); } catch(err) {}
                await Await(JSRoutine.BASE_WAIT);
            }
            return true;
        }

        let nextTick = async () => {

            // get sleep interval time from callback function
            try {
                let {result, during} = await JSRoutine.Task(fn, _currentRoutine)({ waitFor, watchFor, currentTick });
                nextTickIntv = parseInt(result, 10) || config.tickIntv;
            } catch(err) {
                state = JSRoutine.ROUTINE_STATE.TERMINATED;
                throw err;
            }
            
            // add tick counter
            currentTick += 1;

        }
        
        // eternal routine, unless terminated
        const routine = async () => {
            while(state !== JSRoutine.ROUTINE_STATE.TERMINATED) {
                if (state === JSRoutine.ROUTINE_STATE.START) await nextTick();
                await Await(nextTickIntv || Math.max(10, config.tickIntv));
                if (!config.infinite && state === JSRoutine.ROUTINE_STATE.START) state = JSRoutine.ROUTINE_STATE.STOP;
            }
        }
        initializedAt = Date.now();
        routine();

        // controller functions
        const start = () => { state = JSRoutine.ROUTINE_STATE.START; initializedAt = Date.now(); return _currentRoutine; };
        const next = () => { if (state !== JSRoutine.ROUTINE_STATE.START) nextTick(); return _currentRoutine; };
        const stop = () => { state = JSRoutine.ROUTINE_STATE.STOP; currentTick = 0; previousRunned = Date.now() - initializedAt; return _currentRoutine; };
        const pause = () => { state = JSRoutine.ROUTINE_STATE.PAUSE; previousRunned = Date.now() - initializedAt; return _currentRoutine; };
        const terminate = () => { state = JSRoutine.ROUTINE_STATE.TERMINATED; previousRunned = Date.now() - initializedAt; return _currentRoutine; };

        const passArg = (key, value) => { if (yieldStack[key]) yieldStack[key].push(value); else yieldStack[key] = [value]; return _currentRoutine; };

        // check if the routine is terminated before each call
        const check = (_fn) => () => {
            if (state === JSRoutine.ROUTINE_STATE.TERMINATED) throw new RoutineError("Cannot operate on a terminated routine.", 0);
            if (_fn && _fn.call) return _fn.call(_fn);
            else return _fn;
        }

        // return routine instance
        return _currentRoutine = {
            get start() {return check(start)},
            get next() {return check(next)},
            get pause() {return check(pause)},
            get stop() {return check(stop)},
            get terminate() {return check(terminate)},

            get passArg() {return passArg},

            get state() {return state},
            get lasts() {return state === JSRoutine.ROUTINE_STATE.START ? Date.now() - initializedAt + previousRunned : previousRunned},
            get tick() {return currentTick},
        }

    }

    /**
     * A simple task with timeout
     * @param {Function} fn 
     * @param {Number} timeout 
     * @param {Context} context(this)
     * @returns {Function} async function to call
     */
    static Task(fn, context=null, timeout=0) {

        // check callback IS a callable
        if (!fn || typeof fn !== 'function') RoutineError.Raise("Only function is accepted to create a task.", RoutineError.ERROR.WRONG_TYPE);
        
        timeout = parseInt(timeout, 10) || 0;
        if (timeout < 0) timeout = 0;
        let finished = false;

        return (...args) => new Promise(async (resolve, reject) => {

            let startAt = Date.now();
            if (timeout > 0) setTimeout(() => {

                if (!finished) {
                    finished = true; 
                    reject({ 
                        error: new RoutineError("Task Timeout!", RoutineError.ERROR.TIMEOUT),
                        during: Date.now() - startAt
                    });
                }

            }, timeout);
    
            try {
    
                let result = await fn.call(context || {}, ...args);
                if (!finished) {
                    finished = true;
                    resolve({
                        result,
                        during: Date.now() - startAt
                    });
                }

            } catch(e) { 
                if (!finished) { 
                    finished = true; 
                    reject({ 
                        error: new RoutineError(e),
                        during: Date.now() - startAt
                    });
                }
            }

        });
    } 
}

/**
 * states for js routine
 */
JSRoutine.ROUTINE_STATE = {
    INIT: 9,
    STOP: -1,
    START: 1,
    PAUSE: 0,
    TERMINATED: -2,
};
JSRoutine.BASE_WAIT = 10;

JSRoutine.DEFAULT_CONF = {
    tickIntv: 10,
    timeout: 0,
    infinite: false
}

module.exports = JSRoutine;